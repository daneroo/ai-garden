# VTT Headers and Metadata Plan

## Goal

Embed provenance metadata into VTT files generated by the whisper app using
`NOTE Provenance` blocks with JSON payloads.

## VTT Specification Reference

**Source**: [W3C WebVTT Spec](https://www.w3.org/TR/webvtt1/)

Relevant sections:

- [1.7 Metadata example](https://www.w3.org/TR/webvtt1/#introduction-metadata) —
  **not using**
- [1.5 Comments in WebVTT](https://www.w3.org/TR/webvtt1/#introduction-comments)
  — **using this**

We leverage the spec's NOTE definition with **our own JSON convention**. This is
compatible with all conforming parsers (NOTE blocks are ignored by design).

---

## Target File

**`bun-one/apps/whisper/lib/vtt.ts`** — the whisper app's VTT utilities.

> [!NOTE]
> `packages/vtt` is a placeholder and is **excluded from this work**.

---

## Decision: One Unified NOTE Format

Use `NOTE Provenance` with JSON for both:

- **Header** (file-level metadata)
- **Segment markers** (where each segment begins)

Same structure, different fields populated. This enables passthrough during
re-stitching.

---

## Proposed Format

### Final Stitched VTT

```vtt
WEBVTT

NOTE Provenance
{"input":"audiobook.mp3","model":"tiny.en","segments":38,"generated":"2024-01-01T12:00:00Z"}

NOTE Provenance
{"segment":0,"input":"audiobook-seg00-d37h-ov0s.wav","startSec":0}

00:00:00.000 --> 00:00:02.000
First cue from segment 0...

NOTE Provenance
{"segment":1,"input":"audiobook-seg01-d37h-ov0s.wav","startSec":133200}

37:00:00.000 --> 37:00:07.040
First cue from segment 1...
```

---

## Schema Definition

A **discriminated union** on the presence of `segment`:

### Header Provenance (file-level)

```typescript
const VttHeaderProvenanceSchema = z.object({
  input: z.string(), // required: source audio basename
  model: z.string(), // required: e.g., "tiny.en"
  generated: z.string(), // required: ISO 8601 timestamp
  segments: z.number().optional(), // if segmented
  startSec: z.number().optional(), // if partial transcription
  durationSec: z.number().optional(), // if partial transcription
  digest: z.string().optional(), // sha256:... (future)
});
```

### Segment Provenance (per-segment marker)

```typescript
const VttSegmentProvenanceSchema = z.object({
  segment: z.number(), // required: 0-based index (discriminant)
  startSec: z.number(), // required: offset in original audio
  input: z.string().optional(), // segment wav filename
});
```

### Combined Schema

```typescript
const VttProvenanceSchema = z.union([
  VttHeaderProvenanceSchema,
  VttSegmentProvenanceSchema,
]);
```

**Discriminant**: If `segment` is present → segment marker; otherwise → header.

> [!NOTE]
> This schema is a **starting point**. The implementer should refine required vs
> optional fields based on what's actually available at runtime.

---

## Implementation Tasks

### Phase 1: Schema & Types

- [ ] Add Zod dependency (`bun add zod`)
- [ ] Define `VttProvenanceSchema` in `lib/vtt.ts`
- [ ] Define `VttFile` interface (`cues: VttCue[]`,
      `provenance?: VttProvenance[]`)

### Phase 2: Parsing

- [ ] Update `parseVtt()` to return `VttFile`
- [ ] Extract `NOTE Provenance` blocks and parse JSON
- [ ] Update `readVtt()` for compatibility

### Phase 3: Formatting & Writing

- [ ] Update `formatVtt()` to accept optional provenance
- [ ] Emit header `NOTE Provenance` before cues
- [ ] Emit segment markers before each segment's cues
- [ ] Update `writeVtt()` to pass through provenance

### Phase 4: Integration

- [ ] Update `stitchSegments()` to accept provenance data
- [ ] Pass `RunConfig` subset through to stitching
- [ ] Build header provenance object at stitch time

### Phase 5: Testing

**Existing tests** (in `test/`):

- `integration_smoke_test.ts` — uses `jfk.m4b` fixture (~11s)
- `vtt-stitch_test.ts` — unit tests for stitch utilities

**New tests needed**:

- [ ] Add provenance parsing tests (extract from VTT string)
- [ ] Add formatting tests (emit `NOTE Provenance` blocks)
- [ ] Extend smoke test: verify output VTT contains provenance header
- [ ] Add stitching test with `roadnottaken.m4b` (~1 min, segmented)
- [ ] Roundtrip test: write → read → verify provenance preserved

**Run**: `bun test` in `apps/whisper/`

---

## Future Considerations

- Digest computation (sha256 of input file) — optional, deferred
- Passthrough of NOTE blocks during re-stitching
- Parsing provenance for cache validation
