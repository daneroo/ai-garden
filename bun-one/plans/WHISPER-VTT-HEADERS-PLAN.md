# VTT Provenance Plan (Revised)

## Goal

Embed provenance metadata into VTT files generated by `apps/whisper` using
`NOTE Provenance` blocks with JSON payloads, without breaking existing cue-only
code paths.

## Scope

This work touches:

- `bun-one/apps/whisper/lib/vtt.ts` (types + parsing)
- `bun-one/apps/whisper/lib/vtt-stitch.ts` (formatting + writing)
- `bun-one/apps/whisper/lib/runners.ts` (stitch integration)
- tests under `bun-one/apps/whisper/test/`

Out of scope:

- `bun-one/packages/vtt` (placeholder package)
- dedupe/smart overlap stitch behavior
- digest/hash computation (deferred)

## Spec Basis

Source: [W3C WebVTT Spec](https://www.w3.org/TR/webvtt1/)

Use WebVTT comment blocks (`NOTE`) from W3C WebVTT. We define a project
convention: `NOTE Provenance` followed by one JSON line.

## Key Decisions

1. Use one unified provenance format:
   - header records (file-level)
   - segment marker records (per stitched segment)
2. Keep compatibility for existing callers:
   - `parseVtt()` and `readVtt()` remain cue-only
   - add `parseVttFile()` and `readVttFile()` for cues + provenance
3. Parse defensively:
   - malformed provenance JSON is ignored (no hard failure)
4. No dependency addition required for v1:
   - use TypeScript types/type guards instead of adding `zod`

## Data Model

```ts
interface VttHeaderProvenance {
  input: string;
  model: string;
  generated: string; // ISO timestamp
  segments?: number;
  startSec?: number;
  durationSec?: number;
  digest?: string; // future
}

interface VttSegmentProvenance {
  segment: number; // 0-based
  startSec: number;
  input: string; // segment wav basename
}

type VttProvenance = VttHeaderProvenance | VttSegmentProvenance;

interface VttFile {
  cues: VttCue[];
  provenance: VttProvenance[];
}
```

Discriminant rule: if `segment` exists -> segment provenance; otherwise header
provenance.

## On-Disk Format

```vtt
WEBVTT

NOTE Provenance
{"input":"audiobook.mp3","model":"tiny.en","segments":38,"generated":"2026-02-03T00:00:00Z"}

NOTE Provenance
{"segment":0,"input":"audiobook-seg00-d1h-ov0s.wav","startSec":0}

00:00:00.000 --> 00:00:02.000
First cue...
```

## Implementation Plan

### Phase 1 - `lib/vtt.ts` parser and API

- [x] Add provenance types (`VttProvenance`, `VttFile`).
- [x] Implement `parseVttFile(vtt: string): VttFile`.
- [x] Implement `readVttFile(path: string): Promise<VttFile>`.
- [x] Keep `parseVtt()` and `readVtt()` as wrappers returning cues only.
- [x] Update parsing logic to consume full NOTE blocks (not only NOTE header
      line).
- [x] Extract only `NOTE Provenance` blocks and parse JSON payload.
- [x] Ignore malformed provenance blocks safely.

### Phase 2 - `lib/vtt-stitch.ts` formatting/writing

- [x] Extend formatting/writing to support provenance records.
- [x] Emit header provenance block before first cue.
- [x] Emit segment provenance blocks at segment boundaries during stitch output.
- [x] Preserve existing cue-only formatting behavior when provenance is omitted.

### Phase 3 - `lib/runners.ts` integration

- [x] Update stitch path to read segment VTTs via `readVttFile()`.
- [x] Build stitched-file header provenance from run config: `input`, `model`,
      `generated`, and optional `segments/startSec/durationSec`.
- [x] Build per-segment provenance entries: `segment`, `startSec`, and segment
      input basename.
- [x] Write final stitched VTT with cues + provenance.

### Phase 4 - Tests

- [x] `lib/vtt` tests: parse provenance blocks, parse cue-only files, malformed
      JSON tolerance.
- [x] `test/vtt-stitch_test.ts`: format emits provenance in correct order.
- [x] Stitch test: segment boundaries produce expected `NOTE Provenance`
      markers.
- [x] `test/integration_smoke_test.ts`: final output contains provenance header
      note.
- [x] Roundtrip test: format/write -> read/parse preserves provenance.

## Acceptance Criteria

- Final stitched VTT includes:
  - exactly one header provenance block
  - segment provenance blocks for included segments
- Existing cue-only callers continue to compile and behave the same.
- Parser handles VTT files with arbitrary NOTE blocks and ignores non-provenance
  NOTE data.
- All whisper app tests pass with no new flakiness.

## Deferred Follow-ups

- Make the next plan - smaller - or have committable phases
- Optional `digest` field (sha256 of source input) for stronger provenance
  identity and future cache-key validation.
- Optional `processingTimeSec` / `elapsedMs` in segment provenance to preserve
  performance metrics across cache hits and improve benchmark interpretation.
- Reorganize artifact directory configuration (`output`, `work`, `cache`) with a
  clear per-input namespace strategy to support discovery and cleanup.
- Define explicit cache consistency policy by caller/use-case (especially
  benchmarks):
  - benchmark mode may disable cache reads entirely (`checkCache: () => false`)
  - or benchmark mode may allow cache but report cache-hit ratio separately
- Refactor `Task` / `TaskConfig` to support non-shell task implementations and
  stronger typed task results.
- Provenance-aware cache validation (deferred until segment-level VTT
  transcription tasks emit provenance before `cache-vtt`; current v1 only adds
  provenance at final stitching)
- Preservation/merge rules for non-provenance `NOTE` blocks during stitch (e.g.,
  preserve first occurrence, merge, or drop with warning).
