---
date: 2026-01-14T16:30:00Z
topic: Recursive M4B Scanner Implementation
tags: bun, yargs, glob, recursion, metadata
last_updated: 2026-01-14T16:30:00Z
---

# Recursive M4B Scanner Implementation Research

## Ticket Synopsis

The goal is to implement a CLI tool that recursively scans for `.m4b` files,
extracting metadata (size, mtime) and outputting it in either Human Readable
(default) or JSON (NDJSON) format. It must handle symlinks (skip/warn) and
permission errors (warn/continue).

## Summary

- **Scanning**: `Bun.Glob` is the most efficient modern way to find files in
  Bun, but `node:fs`'s `readdir` with `recursive: true` offers more granular
  control for error handling and symlink detection if needed. However, since we
  need to "warn and skip" symlinks, a manual traversal or a controlled Glob scan
  is best. _Decision: Use `fs.readdir` recursively or a walker function to
  strictly control symlink handling and error catching per directory._
- **Arguments**: `yargs` handles defaults easily.
  `default: process.env.ROOTPATH || ...` works.
- **Metadata**: `fs.stat(path)` provides `size` and `mtime`.
- **Output**:
  - **Human**: `basename : size : mtime`
  - **JSON**: `JSON.stringify({ basename, size, mtime })`

## Detailed Findings

### Recursive Scanning Strategy

`Bun.Glob` is fast but might hide symlink details or fail silently on
permissions depending on configuration. A safer approach for explicit
requirements (warn on symlinks, warn on access denied) is a manual recursive
generator:

```typescript
import { lstat, readdir, stat } from "node:fs/promises";
import { join } from "node:path";

async function* scan(dir: string): AsyncGenerator<string> {
  try {
    const files = await readdir(dir);
    for (const file of files) {
      const path = join(dir, file);
      try {
        const stats = await lstat(path); // Use lstat to detect symlinks
        if (stats.isSymbolicLink()) {
          console.error(`Warning: Skipping symlink ${path}`);
          continue;
        }
        if (stats.isDirectory()) {
          yield* scan(path);
        } else if (file.endsWith(".m4b")) {
          yield path;
        }
      } catch (err) {
        console.error(`Warning: Cannot access ${path}: ${err.message}`);
      }
    }
  } catch (err) {
    console.error(`Warning: Cannot access directory ${dir}: ${err.message}`);
  }
}
```

### Metadata Extraction

- **Size**: `stats.size` (bytes). Needs conversion function.
  - Function: `formatBytes(bytes: number): string`
- **Time**: `stats.mtime.toISOString()`

### Yargs Configuration

```typescript
yargs(hideBin(process.argv))
  .option("rootpath", {
    alias: "r",
    type: "string",
    default: process.env.ROOTPATH || "/Volumes/Space/Reading/audiobooks/",
    describe: "Root directory to scan",
  })
  .option("json", {
    type: "boolean",
    default: false,
    describe: "Output in JSON format",
  });
```

## Architecture Insights

- **Separation of Concerns**: Keep the scanner logic separate from the
  presentation (CLI output) logic.
- **Streams**: The scanner should ideally yield results as they are found
  (AsyncGenerator) so the CLI can print lines immediately, rather than waiting
  for the whole scan. This fits the "print a line for each" requirement
  perfectly.

## Next Steps

Proceed to **Plan** to implement the `scanner` module and integrate it into
`index.ts`.
